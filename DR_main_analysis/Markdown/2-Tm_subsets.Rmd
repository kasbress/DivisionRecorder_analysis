---
title: "Subgrouping memory T cells"
author: "Kaspar Bresser"
date: "31/08/2021"
output: 
  github_document:
    toc: TRUE
  html_document: 
    theme: simplex
    highlight: pygments
    code_folding: show
    self_contained: TRUE
    toc: yes
    toc_float:
      collapsed: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message=FALSE,
                      autodep  = TRUE,
                      cache = FALSE,
                      fig.width = 5,
                      fig.asp = 0.618,
                      fig.align = "center")

```

# Load packages and data

In the DivisionRecorder manuscript we roughly cluster the identified memory T cell MetaCells into multipotent, effector-like and terminally differentiated cells. Below are the analysis performed to obtain the figures presented that support this clustering.

Start off with loading in the required packages and the data used in the analysis. 

We'll need the metacell object (containing cellcode-MC pairs, plus gene-enrichment values), the seurat object (containing all UMI count data), and the mc2d object (the 2d projection generated by the metacell algorithm).

```{r loading}
library(here)
library(tidyverse)
library(metacell)
library(Seurat)
library(pheatmap)
library(rstatix)
library(ggpubr)
library(viridis)
library(RColorBrewer)

# point the metacell package to the data directory
scdb_init(here("Data"), force_reinit=T)

# import metacell objects
mc <- scdb_mc("DivRecMEM_MC")
MC.graph <- scdb_mc2d("DivRecMEM_MC")

# import seurat object
memory.seurat <- read_rds(here("Data", "seurat_object_all_exps.rds"))

```


# Define and visualize Tcm/Tem subsets

## Get normalized UMI counts

The data was obtained in two different experiments. We'll subset the seurat object by experiment in order to normalize within each experiment.

```{r subset_seurat_object}
memory.seurat@meta.data %>% 
  filter(experiment %in% c("Mem.exp.2.1", "Mem.exp.2.2")) %>% 
  rownames -> exp2.cells
memory.seurat@meta.data %>% 
  filter(experiment %in% c( "Mem.exp.1")) %>% 
  rownames -> exp1.cells

UMI.data.1 <- subset(memory.seurat, cells = exp1.cells)
UMI.data.2 <- subset(memory.seurat, cells = exp2.cells)
```

Now we can normalize and scale the UMI counts using the build in Seurat functions

```{r normalize_and_scale, cache=TRUE, cache.lazy = FALSE}
UMI.data.2 <- NormalizeData(UMI.data.2, assay = "RNA", normalization.method = "CLR")
UMI.data.1 <- NormalizeData(UMI.data.1, assay = "RNA", normalization.method = "CLR")

```

Extract normalized UMI counts, tidy, and combine experiments.

```{r get_scaled_counts}
UMI.data.2 %>% 
  GetAssayData( slot = "data", assay = "RNA")%>% 
  as.matrix %>%
  t %>% 
  as.data.frame %>% 
  rownames_to_column("cellcode") %>% 
  as_tibble -> UMI.data.2
UMI.data.1 %>% 
  GetAssayData( slot = "data", assay = "RNA")%>% 
  as.matrix %>%
  t %>% 
  as.data.frame %>% 
  rownames_to_column("cellcode") %>% 
  as_tibble -> UMI.data.1

UMI.data.1 %>% 
  bind_rows(UMI.data.2) -> all.UMI.counts
all.UMI.counts
```


## Prep for plotting

Next we'll select just the genes we need for plotting the signatures we're interested in and add the 2D projection info.

In the manuscript we focus on two small signatures, representing key multipotency- or effector-associated genes.

```{r signatures}
eff.genes <-c("Tbx21", "Prdm1", "Id2", "Gzmb", "Klrg1", "Cx3cr1", "Prf1", "Lgals1","Ifng")
mult.genes <- c("Eomes", "Il7r","Sell", "Tcf7", "Bcl2", "Ccr7","Myb", "Bach2")
```

Get the coordinates from the 2D object, store as tibble.

```{r get_2D_coords}
coords <- tibble( cellcode = names(MC.graph@sc_y),
                  sc.x = MC.graph@sc_x,
                  sc.y = MC.graph@sc_y)
coords
```

Now subset the UMI count table and combine with coordinates.

```{r join_coords_UMI}
all.UMI.counts %>% 
  dplyr::select(one_of("cellcode", eff.genes, mult.genes)) %>% 
  right_join(coords, scaled.data, by = "cellcode") %>% 
  na.omit() -> all.UMI.counts

```


## Highlight eff/mult genes

First we'll have a look at scatter plot 2d projection of all the MetaCells. Join the location information with the MC-ids and make a scatter plot

```{r MCs_2D}
enframe(as.factor(mc@mc), name = "cellcode", value = "MC") %>% 
  right_join(all.UMI.counts) %>% 
ggplot( aes(x=sc.x, y=sc.y, color = MC))+ 
  geom_point(size = 0.5)+
  theme_classic()+ 
  theme(legend.position = "right")+
  scale_color_viridis_d()
ggsave(filename = here("Figs", "2d_proj_MCs.pdf"), device = "pdf", width = 5.2,height = 4)

```

Now lets look at the effector and multipotency signatures highlighted on top of the metacell projection. Starting off with the effector signature.

```{r plot_effector, fig.asp=.8}
all.UMI.counts %>% 
  mutate(effector = rowSums( scale(select(.,one_of(eff.genes))) )) %>% 
  mutate(effector.capped = case_when(effector > 10 ~ 10,
                                     TRUE ~ effector)) -> all.UMI.counts

## Plot effector signature
all.UMI.counts %>% 
#  sample_n(nrow(.))%>%
  arrange(effector) %>% 
  ggplot( aes(x=sc.x, y=sc.y, color = effector.capped))+ 
  geom_point(size = 0.2)+
  scale_color_gradient2(low= "dodgerblue3", high= "red3", mid= "white", midpoint =0)+
  theme_classic()
ggsave(filename = here( "Figs","effector_sig.pdf"), device = "pdf", width = 4,height = 3)
```

And the same for the multipotency signature!

```{r plot_multipo, fig.asp=.8}
all.UMI.counts %>% 
  mutate(multipo = rowSums( scale(select(.,one_of(mult.genes))) )) %>% 
  mutate(multipo.capped = case_when(multipo > 10 ~ 10,
                                     TRUE ~ multipo)) -> all.UMI.counts

## Plot effector signature
all.UMI.counts %>% 
#  sample_n(nrow(.))%>%
  arrange(multipo) %>% 
  ggplot( aes(x=sc.x, y=sc.y, color = multipo.capped))+ 
  geom_point(size = 0.2)+
  scale_color_gradient2(low= "dodgerblue3", high= "red3", mid= "white", midpoint =0)+
  theme_classic()
ggsave(filename = here( "Figs","multipo_sig.pdf"), device = "pdf", width = 4,height = 3)
```


## Subsetting for Tcm and Tem

Look at the same 2d plot, but now show Tem, Tcm identities based on transcriptome. This selection was made guided by the signature expression as seen above. There we found that MC17, 19, 20 and 21 appear to be effector memory cells. 

Will add this distinction as a column, and make the plot.

```{r plot_Tem_Tcm, fig.asp=.8}
enframe(as.factor(mc@mc), name = "cellcode", value = "MC") %>% 
  right_join(all.UMI.counts) %>% 
  mutate(phenotype = case_when(MC %in% c('21','19','17','20') ~ "Tem",
                               TRUE ~ "Tcm") ) %>% 
ggplot( aes(x=sc.x, y=sc.y, color = phenotype))+ 
  geom_point(size = 0.5)+
  theme_classic()+ 
  theme(legend.position = "right")+
  scale_color_manual(values = c("#0036A8","#C1272D"))
ggsave(filename = here( "Figs","2d_proj_phenotype.pdf"), device = "pdf", width = 4,height = 3)

```

To check if our subdivision was sensible, lets plot the expression of the signatures, and some marker genes as violins. 

Prep the data, pivot to longer data, and clean up a bit. Removed the super high signature scores, for visualization.

```{r violin_prep}
to.plot <- c("Bcl2", "Il7r", "Sell", "multipo", "Klrg1", "Cx3cr1", "Gzmb", "effector")

enframe(as.factor(mc@mc), name = "cellcode", value = "MC") %>% 
  right_join(all.UMI.counts) %>% 
  mutate(phenotype = case_when(MC %in% c('21','19','17','20') ~ "Tem",
                               TRUE ~ "Tcm") ) %>% 
  select(one_of(c(to.plot, "MC", "phenotype")) ) %>% 
  pivot_longer(cols = one_of(c(to.plot, "multipo", "effector")), names_to =  "gene", values_to = "expression") %>% 
  mutate(gene = factor(gene, to.plot)) %>% 
  na.omit() %>% 
  filter(expression < 20)-> for.violins
for.violins
```

Now we can use that table to generate some violins


```{r make_violins, fig.asp=.5}
ggplot(for.violins, aes(x = phenotype, y = expression, fill = phenotype))+
  geom_violin(scale = "width")+
  facet_wrap(~gene, scales = "free_y", nrow = 2)+
  scale_fill_manual(values = c("#0036A8","#C1272D"))
ggsave(here("Figs", "Violins_Tcm_Tem.pdf"), width = 5, height = 2.5)
```


# Define and visualize Tcm sub-clusters

## Get gene-enrichment values

Using the enrichment values of genes across MetaCells, we identified a sub-clustering within Tcm that could be identified as more effector-like and more multipotent-like Tcm. 

Below are the analysis performed to produce the figures depicted in the manuscript. 

We'll be using the gene-enrichment values of the MetaCells, calculated using the metacell package, to look at enrichments and/or depletion of expression of genes of interest. Start off with extracting that information from the metacell object.

```{r get_lfp}
lfp <- log2(mc@mc_fp)

dim(lfp)
```

For visualizing the data in the form of a heatmap we'll use the genes from our multipotency and effector signatures that we used above. Also, transform to a matrix, as that is the input for the `pheatmap` function.

```{r prep_heatmap}
lfp %>% 
  as

to.plot <- as.matrix(lfp[c(eff.genes, mult.genes),])

dim(to.plot)

to.plot %>% 
  as.data.frame() %>% 
  write_tsv(here("Output", "Fig_4b.tsv"))
```


## Heatmap (with Tem)


```{r heatmap_with, fig.asp=.85}
hm <- pheatmap(mat = to.plot,  scale = "row", clustering_distance_rows = "euclidean",
         clustering_distance_cols = "correlation", breaks = seq(-1.5,1.5,by=0.03),
         color = colorRampPalette(rev(brewer.pal(n = 7, name ="RdYlBu")))(100), cutree_rows = 2, cutree_cols = 2)

hm

pdf(here("Figs", "heatmap_eff_vs_multWterm.pdf"), height = 5, width = 10)
hm
dev.off()
```

## Heatmap (without Tem)


```{r heatmap_without, fig.asp=.85}
to.plot <- to.plot[,-c(17,19,20,21)]
hm <- pheatmap(mat = to.plot,  scale = "row", clustering_distance_rows = "euclidean",
         clustering_distance_cols = "correlation", breaks = seq(-1.5,1.5,by=0.03),
         color = colorRampPalette(rev(brewer.pal(n = 7, name ="RdYlBu")))(100), cutree_rows = 2, cutree_cols = 2)

hm

pdf(here("Figs", "heatmap_eff_vs_multWterm.pdf"), height = 5, width = 10)
hm
dev.off()
```


## Boxplots marker genes

We'll make some boxplots to visualize the expression of some key genes in each defined cluster. First we'll prep the enrichment-values and tidy, so the selected genes are mapped to a specific column. 

```{r boxplot_prep}
select.genes <- c("Klrg1", "Cx3cr1", "Gzma", "Zeb2" , "Prdm1", "Tbx21", "Bcl2", "Cd27", "Xcl1", "Ccr7", "Il7r", "Sell")

as.data.frame(lfp) %>% 
  rownames_to_column("genes") %>% 
  as_tibble() %>% 
  dplyr::filter(genes %in% select.genes) %>% 
  mutate(genes = factor(genes, levels = select.genes)) %>% 
  pivot_longer(cols = -genes, names_to = "metacell", values_to =  "lfp") %>% 
  mutate(cluster = factor(fct_collapse(.$metacell,
                                       eff = c('23','15','22','8','6','10','4','5','7','18'),
                                       mult = c('9','1','12','13','14','16','11','2','3'),
                                       term = c('21','19','17','20')), 
                          levels = c("term", "eff", "mult")  ) ) -> to.plot
to.plot

write_tsv(to.plot, here("Output", "Fig_4c.tsv"))
```

Next, calculate some statistics using the `rstatix` package. 

```{r calc_stats}
to.plot %>%
  group_by(genes) %>%
  tukey_hsd(lfp ~ cluster)%>%
  add_y_position(scales = "free_y", fun = "max", step.increase = 0.2) -> stat.test
stat.test
```

And finally, plot the data as boxplots. Used the `stat_pvalue_manual` function from `ggpubr` to add P values to the plot. 

```{r make_boxplots, fig.asp=.5, fig.width=8}
ggplot(to.plot, aes(x = cluster, y = lfp, color = cluster ))+
  geom_boxplot(outlier.shape = NA)+
  scale_color_manual(values = c("#C1272D","#4575B4" ,"#8AB8D7"))+
  geom_jitter(color = "black", width = .2, size = .8)+
  facet_wrap(~genes, scales = "free", nrow = 2)+
  stat_pvalue_manual(data = stat.test, label = "p.adj", label.size = 3, hide.ns = T, tip.length = 0.02) +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.1)))+
  theme(strip.background = element_blank())
  
ggsave( here("Figs","boxplots_lfp.pdf"), device = "pdf", width = 8, height = 4)
```

